{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = defaultCellRangeRenderer;\n\nvar _types = require(\"./types\");\n/**\r\n * Default implementation of cellRangeRenderer used by Grid.\r\n * This renderer supports cell-caching while the user is scrolling.\r\n */\n\n\nfunction defaultCellRangeRenderer(_ref) {\n  var cellCache = _ref.cellCache,\n      cellRenderer = _ref.cellRenderer,\n      columnSizeAndPositionManager = _ref.columnSizeAndPositionManager,\n      columnStartIndex = _ref.columnStartIndex,\n      columnStopIndex = _ref.columnStopIndex,\n      deferredMeasurementCache = _ref.deferredMeasurementCache,\n      horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment,\n      isScrolling = _ref.isScrolling,\n      isScrollingOptOut = _ref.isScrollingOptOut,\n      parent = _ref.parent,\n      rowSizeAndPositionManager = _ref.rowSizeAndPositionManager,\n      rowStartIndex = _ref.rowStartIndex,\n      rowStopIndex = _ref.rowStopIndex,\n      styleCache = _ref.styleCache,\n      verticalOffsetAdjustment = _ref.verticalOffsetAdjustment,\n      visibleColumnIndices = _ref.visibleColumnIndices,\n      visibleRowIndices = _ref.visibleRowIndices;\n  var renderedCells = []; // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).\n  // User cannot scroll beyond these size limitations.\n  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.\n  // We should never cache styles for compressed offsets though as this can lead to bugs.\n  // See issue #576 for more.\n\n  var areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();\n  var canCacheStyle = !isScrolling && !areOffsetsAdjusted;\n\n  for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n    var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);\n\n    for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n      var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);\n      var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;\n      var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\n      var style = void 0; // Cache style objects so shallow-compare doesn't re-render unnecessarily.\n\n      if (canCacheStyle && styleCache[key]) {\n        style = styleCache[key];\n      } else {\n        // In deferred mode, cells will be initially rendered before we know their size.\n        // Don't interfere with CellMeasurer's measurements by setting an invalid size.\n        if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {\n          // Position not-yet-measured cells at top/left 0,0,\n          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.\n          // Positioning them further to the right/bottom influences their measured size.\n          style = {\n            height: 'auto',\n            left: 0,\n            position: 'absolute',\n            top: 0,\n            width: 'auto'\n          };\n        } else {\n          style = {\n            height: rowDatum.size,\n            left: columnDatum.offset + horizontalOffsetAdjustment,\n            position: 'absolute',\n            top: rowDatum.offset + verticalOffsetAdjustment,\n            width: columnDatum.size\n          };\n          styleCache[key] = style;\n        }\n      }\n\n      var cellRendererParams = {\n        columnIndex: columnIndex,\n        isScrolling: isScrolling,\n        isVisible: isVisible,\n        key: key,\n        parent: parent,\n        rowIndex: rowIndex,\n        style: style\n      };\n      var renderedCell = void 0; // Avoid re-creating cells while scrolling.\n      // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n      // If a scroll is in progress- cache and reuse cells.\n      // This cache will be thrown away once scrolling completes.\n      // However if we are scaling scroll positions and sizes, we should also avoid caching.\n      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.\n      // For more info refer to issue #395\n      //\n      // If isScrollingOptOut is specified, we always cache cells.\n      // For more info refer to issue #1028\n\n      if ((isScrollingOptOut || isScrolling) && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {\n        if (!cellCache[key]) {\n          cellCache[key] = cellRenderer(cellRendererParams);\n        }\n\n        renderedCell = cellCache[key]; // If the user is no longer scrolling, don't cache cells.\n        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.\n      } else {\n        renderedCell = cellRenderer(cellRendererParams);\n      }\n\n      if (renderedCell == null || renderedCell === false) {\n        continue;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        warnAboutMissingStyle(parent, renderedCell);\n      }\n\n      renderedCells.push(renderedCell);\n    }\n  }\n\n  return renderedCells;\n}\n\nfunction warnAboutMissingStyle(parent, renderedCell) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (renderedCell) {\n      // If the direct child is a CellMeasurer, then we should check its child\n      // See issue #611\n      if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {\n        renderedCell = renderedCell.props.children;\n      }\n\n      if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {\n        parent.__warnedAboutMissingStyle = true;\n        console.warn('Rendered cell should include style property for positioning.');\n      }\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Sebastian/Documents/code projects/DIrtyLittlePaws/node_modules/react-virtualized/dist/commonjs/Grid/defaultCellRangeRenderer.js"],"names":["Object","defineProperty","exports","value","defaultCellRangeRenderer","_types","require","_ref","cellCache","cellRenderer","columnSizeAndPositionManager","columnStartIndex","columnStopIndex","deferredMeasurementCache","horizontalOffsetAdjustment","isScrolling","isScrollingOptOut","parent","rowSizeAndPositionManager","rowStartIndex","rowStopIndex","styleCache","verticalOffsetAdjustment","visibleColumnIndices","visibleRowIndices","renderedCells","areOffsetsAdjusted","canCacheStyle","rowIndex","rowDatum","getSizeAndPositionOfCell","columnIndex","columnDatum","isVisible","start","stop","key","concat","style","has","height","left","position","top","width","size","offset","cellRendererParams","renderedCell","process","env","NODE_ENV","warnAboutMissingStyle","push","type","__internalCellMeasurerFlag","props","children","undefined","__warnedAboutMissingStyle","console","warn"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports[\"default\"] = defaultCellRangeRenderer;\r\n\r\nvar _types = require(\"./types\");\r\n\r\n/**\r\n * Default implementation of cellRangeRenderer used by Grid.\r\n * This renderer supports cell-caching while the user is scrolling.\r\n */\r\nfunction defaultCellRangeRenderer(_ref) {\r\n  var cellCache = _ref.cellCache,\r\n      cellRenderer = _ref.cellRenderer,\r\n      columnSizeAndPositionManager = _ref.columnSizeAndPositionManager,\r\n      columnStartIndex = _ref.columnStartIndex,\r\n      columnStopIndex = _ref.columnStopIndex,\r\n      deferredMeasurementCache = _ref.deferredMeasurementCache,\r\n      horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment,\r\n      isScrolling = _ref.isScrolling,\r\n      isScrollingOptOut = _ref.isScrollingOptOut,\r\n      parent = _ref.parent,\r\n      rowSizeAndPositionManager = _ref.rowSizeAndPositionManager,\r\n      rowStartIndex = _ref.rowStartIndex,\r\n      rowStopIndex = _ref.rowStopIndex,\r\n      styleCache = _ref.styleCache,\r\n      verticalOffsetAdjustment = _ref.verticalOffsetAdjustment,\r\n      visibleColumnIndices = _ref.visibleColumnIndices,\r\n      visibleRowIndices = _ref.visibleRowIndices;\r\n  var renderedCells = []; // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).\r\n  // User cannot scroll beyond these size limitations.\r\n  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.\r\n  // We should never cache styles for compressed offsets though as this can lead to bugs.\r\n  // See issue #576 for more.\r\n\r\n  var areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();\r\n  var canCacheStyle = !isScrolling && !areOffsetsAdjusted;\r\n\r\n  for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\r\n    var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);\r\n\r\n    for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\r\n      var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);\r\n      var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;\r\n      var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\r\n      var style = void 0; // Cache style objects so shallow-compare doesn't re-render unnecessarily.\r\n\r\n      if (canCacheStyle && styleCache[key]) {\r\n        style = styleCache[key];\r\n      } else {\r\n        // In deferred mode, cells will be initially rendered before we know their size.\r\n        // Don't interfere with CellMeasurer's measurements by setting an invalid size.\r\n        if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {\r\n          // Position not-yet-measured cells at top/left 0,0,\r\n          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.\r\n          // Positioning them further to the right/bottom influences their measured size.\r\n          style = {\r\n            height: 'auto',\r\n            left: 0,\r\n            position: 'absolute',\r\n            top: 0,\r\n            width: 'auto'\r\n          };\r\n        } else {\r\n          style = {\r\n            height: rowDatum.size,\r\n            left: columnDatum.offset + horizontalOffsetAdjustment,\r\n            position: 'absolute',\r\n            top: rowDatum.offset + verticalOffsetAdjustment,\r\n            width: columnDatum.size\r\n          };\r\n          styleCache[key] = style;\r\n        }\r\n      }\r\n\r\n      var cellRendererParams = {\r\n        columnIndex: columnIndex,\r\n        isScrolling: isScrolling,\r\n        isVisible: isVisible,\r\n        key: key,\r\n        parent: parent,\r\n        rowIndex: rowIndex,\r\n        style: style\r\n      };\r\n      var renderedCell = void 0; // Avoid re-creating cells while scrolling.\r\n      // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\r\n      // If a scroll is in progress- cache and reuse cells.\r\n      // This cache will be thrown away once scrolling completes.\r\n      // However if we are scaling scroll positions and sizes, we should also avoid caching.\r\n      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.\r\n      // For more info refer to issue #395\r\n      //\r\n      // If isScrollingOptOut is specified, we always cache cells.\r\n      // For more info refer to issue #1028\r\n\r\n      if ((isScrollingOptOut || isScrolling) && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {\r\n        if (!cellCache[key]) {\r\n          cellCache[key] = cellRenderer(cellRendererParams);\r\n        }\r\n\r\n        renderedCell = cellCache[key]; // If the user is no longer scrolling, don't cache cells.\r\n        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.\r\n      } else {\r\n        renderedCell = cellRenderer(cellRendererParams);\r\n      }\r\n\r\n      if (renderedCell == null || renderedCell === false) {\r\n        continue;\r\n      }\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        warnAboutMissingStyle(parent, renderedCell);\r\n      }\r\n\r\n      renderedCells.push(renderedCell);\r\n    }\r\n  }\r\n\r\n  return renderedCells;\r\n}\r\n\r\nfunction warnAboutMissingStyle(parent, renderedCell) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (renderedCell) {\r\n      // If the direct child is a CellMeasurer, then we should check its child\r\n      // See issue #611\r\n      if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {\r\n        renderedCell = renderedCell.props.children;\r\n      }\r\n\r\n      if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {\r\n        parent.__warnedAboutMissingStyle = true;\r\n        console.warn('Rendered cell should include style property for positioning.');\r\n      }\r\n    }\r\n  }\r\n}"]},"metadata":{},"sourceType":"script"}